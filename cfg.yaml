Name: tenant          #  the tenant name
AquaServer:           #  url of Aqua Server for links. E.g. https://myserver.aquasec.com
Max_DB_Size: 1000     #  Max size of DB. MB. if empty then unlimited
Delete_Old_Data: 10   #  delete data older than N day(s).  If empty then we do not delete.
DbVerifyInterval: 1   #  hours. an Interval between tests of DB. Default: 1 hour

routes:
- name: route1      #  name must be unique
  input: contains(input.image, "alpine")          #  REGO rules
  output:           #  an integration output which will receive a scan or an audit event
  template:         #  a template for this route
  Aggregate-Issues-Number:   #  a number of scans to aggregate into one ticket
  Aggregate-Issues-Timeout:    #  number of seconds, minutes, hours to aggregate, maximum is 24 hours Xs or Xm or Xh)
  Policy-Show-All:  # Optional. Open a ticket even if a ticket was opened for same image with same amount of vulnerabilities. Default is false.

templates:
- name: raw         #  name must be unique
  body: |           #  REGO rules for a template
- name: slack-template
  body: |
    package postee
    duplicate(a, b, col) = a {col == 1}
    duplicate(a, b, col) = b {col == 2}

    clamp(a, b) = b { a > b }
    clamp(a, b) = a { a <= b }

    by_flag(a, b, flag) = a {
      flag
    }
    by_flag(a, b, flag) = b {
      flag = false
    }


    slice(vlnrb, severity)  = [ s |
        group_size := 5
        num_chunks := ceil(count(vlnrb) / group_size) - 1
        indices := { b | b := numbers.range(0, num_chunks)[_] * group_size }
        fields:=[array.slice(vlnrb, i, i + group_size) | i := indices[_]][_]

        list_caption := sprintf("*%s severity vulnerabilities*", [severity])  #TODO make first char uppercase

        col:=numbers.range(1, 2)[_]
        s := duplicate(
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": list_caption
            }
          },
          {
            "type": "section",
            "fields":fields

          },
          col
        )
      ] {
      count(vlnrb) > 0
    }
    slice(vlnrb, severity) = [] {
      count(vlnrb) == 0
    }



    vln_list(severity) = l {
      vlnrb := [r |
              item := input.resources[_]
              resource := item.resource
              vlnname := item.vulnerabilities[_].name
              fxvrsn := item.vulnerabilities[_].fix_version
              item.vulnerabilities[_].aqua_severity == severity
              col:=numbers.range(1, 2)[_]
              r := duplicate(
                {"type": "mrkdwn", "text": vlnname},
                {"type": "mrkdwn", "text": concat("/", [resource.name, resource.version, fxvrsn])},
                col
              )
            ]

      l := slice(vlnrb, severity)
    }
    by_severity(severity)= l {

      l:= [r |

          item := input.resources[_]
          item.vulnerabilities[_].aqua_severity == severity

          r := item.vulnerabilities[_]
          ]
    }

    # Object comprehension example
    #severity_stats:= {severities[i]: cnt |
    #	cnt:= count(by_severity(severities[i]))
    #}
    check_failed(item) = false {
    not item.failed
    }
    check_failed(item) = true {
    item.failed
    }

    result = res {
      severities := ["critical", "high", "medium", "low", "negligible"]

      severity_stats:= [gr |
          severity := severities[_]
          col:=numbers.range(1, 2)[_]
          gr:= duplicate(
            {"type": "mrkdwn", "text": sprintf("*%s*", [upper(severity)])},
            {"type": "mrkdwn", "text": sprintf("*%d*", [count(by_severity(severity))])},
            col
          )
      ]

      checks_performed:= [check |
              item := input.image_assurance_results.checks_performed[i]
              col:=numbers.range(1, 2)[_]
              check:= duplicate(
                {"type": "mrkdwn", "text": sprintf("%d %s*", [i+1, item.control])},
                {"type": "mrkdwn", "text": concat(" / ", [item.policy_name, check_failed(item)])},
                col
              )

      ]

      headers := [{"type":"section","text":{"type":"mrkdwn","text":sprintf("Image name: %s", [input.image])}},
            {"type":"section","text":{"type":"mrkdwn","text":sprintf("Registry: %s", [input.registry])}},
            {"type":"section","text":{"type":"mrkdwn","text": by_flag(
                                        "Image is non-compliant",
                                        "Image is compliant",
                                        input.image_assurance_results.disallowed
                                      )}},
            {"type":"section","text":{"type":"mrkdwn","text": by_flag(
                                        "Malware found: Yes",
                                        "Malware found: No",
                                        input.scan_options.scan_malware #reflects current logic
                                      )}},
            {"type":"section","text":{"type":"mrkdwn","text": by_flag(
                                        "Sensitive data found: Yes",
                                        "Sensitive data found: No",
                                        input.scan_options.scan_sensitive_data #reflects current logic
                                      )}},
            {
            "type": "section",
            "fields": severity_stats
            },
            {
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "*Assurance controls*"
              }
            },
            {
            "type": "section",
            "fields": array.concat(
              [{
                "type": "mrkdwn",
                "text": "*#* *Control*"
              },
              {
                "type": "mrkdwn",
                "text": "*Policy Name* / *Status*"
              }], checks_performed)
            },
            {
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "*Found vulnerabilities*"
              }
            }
            ]

      all_vln1 := array.concat(vln_list("critical"), vln_list("high"))
      all_vln2 = array.concat(all_vln1, vln_list("medium"))
      all_vln3 = array.concat(all_vln2, vln_list("low"))
      all_vln4 = array.concat(all_vln3, vln_list("negligible"))
      res:= array.concat(headers, all_vln4)
    }

outputs:
- name: my-jira   #  name must be unique
  type: jira   #  supported types: jira, email
  enable: true
  url:   # Mandatory. E.g "https://johndoe.atlassian.net"
  user:  # Mandatory. E.g :johndoe@gmail.com"
  password:  # Mandatory. Specify Jira user API key
  project_key:  # Mandatory. Specify the JIRA product key
  tls_verify: false
  board:  # Optional. Specify the Jira board name to open tickets on
  labels:  # Optional, specify array of labels to add to Ticket, for example: ["label1", "label2"]
  issuetype:  # Optional. Specifty the issue type to open (Bug, Task, etc.). Default is "Task"
  priority:   # Optional. Specify the issues severity. Default is "High"
  assignee:   # Optional. Specify the assigned user. Default is the user that opened the ticket

- name: my-email
  type: email
  enable: true
  user:  # Mandatory: SMTP user name (e.g. johndoe@gmail.com)
  password:  # Mandatory: SMTP password
  host:  # Mandatory: SMTP host name (e.g. smtp.gmail.com)
  port:  # Mandatory: SMTP server port (e.g. 587)
  sender:  # Mandatory: The email address to use as a sender
  recipients: ["", ""]  # Mandatory: comma separated list of recipients

- name: my-email-smtp-server
  type: email
  enable: true
  UseMX: true
  sender:  # Mandatory: The email address to use as a sender
  recipients: ["", ""]  # Mandatory: comma separated list of recipients

- name: my-other-email  # this is an example for multiple integrations of same type
  type: email
  enable: true
  user:  # Mandatory: SMTP user name (e.g. johndoe@gmail.com)
  password:  # Mandatory: SMTP password
  host:  # Mandatory: SMTP host name (e.g. smtp.gmail.com)
  port:  # Mandatory: SMTP server port (e.g. 587)
  sender:  # Mandatory: The email address to use as a sender
  recipients: ["", ""]  # Mandatory: comma separated list of recipients

- name: my-slack
  type: slack
  enable: true
  url: https://hooks.slack.com/services/TAAAA/BBB/<key>

- name: ms-team
  type: teams
  enable: true
  url: https://outlook.office.com/webhook/....   #  Webhook's url
  Policy-OPA: ["/config/policy.rego"]

- name: webhook
  type: webhook
  enable: true
  url: https://..../webhook/   #  Webhook's url

- name: splunk
  type: splunk
  enable: true
  url: http://localhost:8088 # Mandatory. Url of a Splunk server
  token: <token> # Mandatory. a HTTP Event Collector Token
  SizeLimit: 10000 # Optional. Maximum scan length, in bytes. Default: 10000

- name: my-servicenow
  type: serviceNow
  enable: true
  user:  # Mandatory. E.g :johndoe@gmail.com"
  password:  # Mandatory. Specify user API key
  instance:  # Mandatory. Name of ServiceN  ow Instance
  board:   #  Specify the ServiceNow board name to open tickets on. Default is "incident"
